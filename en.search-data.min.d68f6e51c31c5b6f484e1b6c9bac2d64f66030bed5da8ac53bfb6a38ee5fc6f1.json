[{"id":0,"href":"/introduction/author/","title":"Who Wrote This?","section":"Introduction","content":" Who is Raj Duggal? # So, you’re curious to know who’s behind this website and why? Let me tell you…\nIt’s been quite the journey—over 25 years in I.T.\nMy software development career started here in Toronto in the mid-90s, a time when tech was very different from today. Back then, software projects followed a strict, step-by-step approach known as the \u0026ldquo;gating\u0026rdquo; system. Projects moved through clearly defined phases: design, development, testing, and finally, deployment. But there was a catch: each phase needed a formal sign-off before moving to the next, which meant endless back-and-forth to get everything “just right” before advancing.\nIn those days, stakeholders would often hold off on signing until they felt 110% sure that everything was perfect, as any further tweaks would require a tedious “change control” process. Change was seen as a problem, something to avoid, and a cause for long debates and delays.\nBut here’s the reality—change always happens. I can’t think of a single project where something didn’t need adjusting midway. Yet, this old-school process led to friction, delays, and a lot of stress all around.\nWhen the Manifesto for Agile Software Development it was a game-changer. It encouraged us to rethink software development from the ground up, embracing change rather than resisting it. The big question was, “If change is inevitable, why not build it right into the process?”\nSince then, I’ve worked with countless clients and watched agile evolve into one of the most popular approaches in software development. But here’s the thing: even though agile is everywhere now, I often see teams missing the core of what it’s really about. They’re using the lingo, but sometimes without fully understanding the purpose behind these practices—how they’re meant to make projects more adaptable, collaborative, and ultimately successful.\nSo, that’s me—a long-time software developer, coach, and consultant, with a focus on helping teams understand and truly live the agile mindset. After all, it’s not about rigidly following processes or sticking to buzzwords; it’s about adapting, growing, and delivering something truly valuable.\n"},{"id":1,"href":"/practices-and-techniques/deploy-mid-sprint/","title":"Deploy Mid-Sprint","section":"Practices and Techniques","content":" Deploy Mid-Sprint # The Benefits of Deploying Mid-Sprint: Why Wait?\nIn many agile teams, there’s an assumption that deployments should happen at the end of each sprint—wrap up all your tasks, complete testing, and deliver everything in one neat package. But is this the best approach? What if we could deploy as soon as each feature or improvement is ready, even if it’s mid-sprint? Here’s why deploying mid-sprint can actually help your team, your product, and your users in more ways than you might expect.\n1. Faster Feedback Loops # One of the biggest benefits of deploying mid-sprint is that it enables faster feedback loops. Instead of waiting until the end of the sprint to get insights from stakeholders, users, or metrics, you’re getting that feedback as soon as new features or changes hit production. This early input can reveal unexpected bugs, usability issues, or misalignments with the product vision. By catching these earlier, you have more time to adjust course, if needed, within the same sprint.\n2. Improved Team Morale and Momentum # Releasing valuable work mid-sprint can be a huge morale booster for the team. Developers get a sense of accomplishment, knowing their work is live and making an impact. This steady progress helps keep motivation high and builds momentum for the team. Each deployment, however small, reinforces that the work matters and contributes to the product’s evolution in real time.\n3. Reduced Pressure and Risk # Waiting until the end of the sprint to deploy can create pressure to cram everything in at once, making the process more stressful and error-prone. If you’ve got all features, bug fixes, and improvements bundled up for one big deployment, a single issue can delay the entire release. Deploying mid-sprint distributes the workload more evenly, minimizing the impact of any single error and allowing for quicker fixes without affecting other parts of the release.\n4. Better User Experience # Frequent, smaller deployments mean users get continuous, incremental improvements rather than having to wait weeks to see new features or fixes. With mid-sprint deployments, you can deliver small enhancements or fixes as soon as they’re ready, keeping users engaged and satisfied. And if something isn’t working quite right, it’s much easier to address and update quickly, preventing small issues from growing into bigger problems.\n5. Easier Testing and Troubleshooting # Deploying mid-sprint gives your QA team and developers smaller, more manageable pieces to test, troubleshoot, and monitor in production. With smaller deployments, it’s easier to isolate and identify issues as they occur, leading to quicker resolutions and a more stable codebase. By addressing issues earlier, you’re maintaining a higher quality product and reducing the chances of major issues piling up before sprint-end.\n6. Supports Continuous Improvement and Learning # One of the core principles of agile is continuous improvement, and mid-sprint deployments feed directly into that philosophy. By deploying smaller chunks of work regularly, teams are in a constant cycle of building, releasing, and learning from real-world results. This process fosters a mindset of experimentation and learning, where teams aren’t waiting for the “perfect” solution but instead are iterating, improving, and adjusting based on actual user needs.\n7. Flexibility to Respond to Changing Priorities # In fast-moving projects, priorities can shift unexpectedly, and sometimes new requirements arise that are crucial to address immediately. Deploying mid-sprint gives teams the flexibility to release higher-priority updates or fixes without waiting for the sprint to end. This flexibility is invaluable in environments where adaptability is key and where meeting customer or market needs quickly can be a competitive advantage.\nMaking Mid-Sprint Deployment Work for Your Team # To get the most out of mid-sprint deployments, a few practices can help ensure everything runs smoothly:\nFeature Toggles: Use feature toggles to control which features are visible to users, allowing you to deploy code without necessarily activating it for everyone.\nAutomated Testing and CI/CD Pipelines: A reliable CI/CD pipeline with automated tests is crucial for frequent deployments. It ensures each change is tested thoroughly and ready for production without requiring a manual, time-intensive process.\nClear Communication: Keep stakeholders informed about the benefits of mid-sprint deployments and how they fit into the overall agile workflow. Having alignment across the team will help keep everyone on the same page.\nMonitor and Iterate: Regularly review the impact of mid-sprint deployments on product quality and team productivity. Use insights from these deployments to continually refine your processes.\nFinal Thoughts # Deploying mid-sprint isn’t just about speed; it’s about delivering continuous value, reducing risk, and fostering a more resilient, adaptable team. When each piece of work is ready to go, don’t let it sit in the backlog or wait until the end of the sprint. Get it into production, get feedback, and keep improving. After all, agile is about responding to change—and there’s no better way to stay responsive than by deploying whenever something is ready, not just at sprint-end.\n"},{"id":2,"href":"/practices-and-techniques/keep-detailed-specs-out-of-user-stories/","title":"Keep Detailed Specifications Out Of User Stories","section":"Practices and Techniques","content":" Keep Detailed Specifications Out Of User Stories\u0026quot; # One of the challenges teams often face when working in agile is balancing high-level user stories with the intricate details of technical specifications. A solution? Keep your detailed specifications as separate documents, and have your user stories refer to them.\nWhy? When specifications are embedded directly in user stories, it can make the stories harder to work with. The stories become bloated and difficult to adjust, split, or discard. By separating the two, you’re free to keep stories focused, lean, and adaptable.\nThe Benefit of Separate Specs and Stories # Separating specifications from stories allows you to:\nWrite user stories that are quick to read and understand, even if they point to a more complex spec. Easily throw out, rewrite, or modify stories as needs change without losing the core specs. Split stories to deliver incremental portions of a feature without being bogged down by every single detail from the specification. Create a clear structure that specifies an entire component’s end goal while delivering parts of it iteratively. This setup is especially useful when building complex features that can be delivered in phases, with each phase being functional and deployable, though not yet fully built out.\nExample: Building a Calendar Component # Let’s say we’re building a calendar component for a website. The final calendar component will include a grid view that’s fully accessible (meeting WCAG standards) and allows users to drag and drop events, both with a mouse and a finger (for mobile devices).\nWe’d create a detailed specification document that outlines everything this calendar should do in its final form. This spec would include:\nThe grid layout and its accessibility features. Drag-and-drop functionality. Design, color contrasts, keyboard navigation, mobile responsiveness, etc. With this specification as a standalone reference, we can then write the first user story as a slice of the full functionality.\nFirst Story Example: Basic Event Listing # User Story 1:\n“As a user, I want to see a list of upcoming dates and events, so I can quickly know what’s scheduled.”\nThis story doesn’t attempt to build the grid or implement any drag-and-drop features. Instead, it provides a basic, deployable solution that lets users see dates and events listed. The story refers back to the full calendar specification, so the team knows it’s part of a bigger picture. But it only addresses a subset of the feature—the event listing.\nAdditional Stories: Incremental Improvements # Later stories can build on this foundation. For instance:\nStory 2: Add a grid structure for events, allowing users to see a month’s layout with dates and events displayed in each cell. Story 3: Enable keyboard navigation to align with accessibility requirements. Story 4: Implement drag-and-drop functionality for events on desktop. Story 5: Extend drag-and-drop to mobile (touchscreen) devices. Each story remains tightly focused while the specification keeps the end goal clear. This approach means you can deliver value to users incrementally, even as the full feature is still under development.\nWhy It Works # By structuring your work this way, you’re making it easier to:\nWrite and rewrite stories without losing sight of the bigger picture. Build and deploy features gradually, without overwhelming your team. Maintain flexibility in your stories, which keeps your process agile, not bogged down by details. Try this approach for your next project and see how much more manageable stories become. With separate specs and stories, you’re setting up your team to build, iterate, and release features effectively—without sacrificing the detailed planning that’s essential to delivering a quality product.\n"},{"id":3,"href":"/practices-and-techniques/qa-as-part-of-development/","title":"QA as Part of Development","section":"Practices and Techniques","content":" QA as Part of Development # One common pitfall in agile teams is treating Quality Assurance (QA) as a step that follows development rather than making it part of the development itself. The reality? Quality needs to be a priority from day one, baked right into the development process.\nLet’s dive into why QA should be woven into the fabric of development—and how this approach can help your team deliver higher-quality work without the stress of last-minute testing and fixes.\nQuality Isn’t an Afterthought—It’s an Integral Part of Development # Quality should be part of every development conversation. As the team clarifies what needs to be done to complete a user story, they should also discuss:\nHow they’ll ensure the work meets quality standards. How they’ll confirm the new feature functions as intended through rigorous testing. With this proactive approach, developers and QA can plan for quality right from the start, pinpointing the areas that need close attention. This doesn’t just improve the final product; it also provides developers with insights into potential risks and unique scenarios they might not consider on their own.\nExample: Considering Shared Code for Multiple Languages # Imagine your team is working on an app with both English and German versions. While much of the app’s logic might be shared across both languages, there may be cases where the code differs slightly between the two. If the development and QA teams work together from the outset, they can establish where testing is needed for each language:\nShared Logic: If English and German versions share the same code for a particular feature, it might only need testing once. Separate Implementations: If there are two separate codebases for English and German, both will need thorough testing to ensure they’re fully functional. By bringing QA into the development process, you get a clear understanding of where testing is essential and where it’s redundant—streamlining the process and minimizing duplicate effort.\nCatching Edge Cases and Exceptional Scenarios Early # Experienced QA professionals are invaluable when it comes to spotting edge cases that developers might overlook. For instance, they might ask:\n“What happens if the database is down? Will the app handle it gracefully, or does it assume the database will always be available?” “How does the application work if a user’s keyboard is set to a right-to-left language, like Arabic or Hebrew?” “Can the app handle email addresses with special characters, like emojis in domain names?” By bringing these questions up early in development, QA helps the team account for unusual but realistic scenarios before they become issues. Addressing these potential pain points before they turn into real bugs saves everyone time and energy.\nReal-Time Collaboration Between Developers and QA # When QA is involved throughout the development process, they can often catch issues as code is being written. If a QA expert notices a potential problem, they can discuss it with the developer immediately, while the code is fresh in their mind. This is a far more efficient approach than waiting until the story is marked “done,” only to find that there’s an issue that requires revisiting code from weeks prior.\nWith QA input at every stage of development, teams can resolve issues faster, with fewer context-switching costs. Developers and QA work together, side by side, to ensure that each user story meets the agreed-upon standards.\nShared Responsibility for High-Quality Code # Ultimately, developers and QA should collaborate on quality. They both play an essential role in delivering robust, dependable features that meet user needs. When quality is a team responsibility, it fosters a shared commitment to high standards and a sense of pride in delivering work that’s reliable from the get-go.\nKey Takeaway: By making QA an integral part of development rather than a post-development step, teams can catch issues early, streamline testing, and ensure they’re building high-quality software from the very start. Agile is all about adapting and improving, so let’s adapt by treating quality as part of development, not something left for later.\n"},{"id":4,"href":"/introduction/whats-the-problem/","title":"What's the Problem?","section":"Introduction","content":" What\u0026rsquo;s the Problem? # Problem? What problem?\nMaybe your project is running smoothly. You know exactly what needs to be done, you\u0026rsquo;ve split up the work into sprints, and everything’s falling into place. Great! Fantastic!\nMaybe agile wasn’t even necessary because you have a clear vision and a well-defined path to reach it. Perfect!\nBut the agile approach wasn’t created for projects where everything is straightforward and well-defined from the start. It was designed for the other type of project—the ones where things aren’t so clear. Where the vision or requirements keep shifting as development goes on, or where the end goal isn’t entirely understood right from the beginning.\nHistorically, those situations led to a lot of stress and strain on teams. Projects would run over budget or off schedule, and developers would get frustrated as they tried to hit a moving target. Agile was developed to help teams handle these types of projects more effectively, to adapt and evolve without derailing everything.\nSo, What’s the Problem? # The problem is that, over the years, agile has drifted from its original intent. When the Agile Manifesto first came out, it sparked great discussions among developers about how to make it work in real-world projects. Early on, some teams began incorporating agile practices, making adjustments along the way. But somewhere down the line, agile started to lose its way.\nMany teams have reverted to old habits. They’ve held onto agile’s terms and ceremonies but have forgotten its core principles. Instead of creating flexibility, they’re back to rigid processes, making everything efficient but not necessarily effective. The very problems agile was supposed to solve are creeping back in!\nNow, many people think they’re “doing agile” because they use the buzzwords and go through the motions. But at its core, they’re still not fully embracing change or recognizing that quality and adaptability go hand in hand.\nThe Role of the Project Manager in Agile # Interestingly, many agile coaches and Scrum Masters might not realize that some of the original founders of agile disagree with how it’s being taught and practiced today. Agile was initially designed from the perspective of the software development team. It didn’t aim to replace project management but to focus on a self-managing team that builds and delivers software with minimal outside interference. However, agile teams still need someone to help clear obstacles, facilitate meetings, and coordinate between departments.\nA good project manager can play a crucial role by handling these broader responsibilities without micromanaging the team. Think of it like a restaurant kitchen: the kitchen staff—the chefs—know their craft. They organize themselves, handle different stations, and work together to ensure every dish comes out just right and on time.\nWhere’s the project manager in this scenario? Well, they’re like the restaurant manager. They don’t need to be in the kitchen telling the chefs how to cook; the chefs already know what they’re doing. Instead, the restaurant manager makes sure everything outside the kitchen is running smoothly: customers are happy, orders are being taken correctly, and the equipment is all functioning as it should.\nEmpowering the Team # In the same way, a project manager doesn’t need to be deeply involved in the day-to-day work of the developers. The team should be empowered to collaborate, solve problems, and figure out the best way to meet the project goals on their own. When issues arise, like missing resources or tooling problems, they should escalate them to the project manager only when necessary.\nIf developers run into a question about requirements, they can talk directly to the business analyst, who acts like the waiter in our restaurant analogy, bringing the customer’s “order” to the kitchen. The goal is to keep things flowing smoothly while letting the experts do what they do best.\n"}]